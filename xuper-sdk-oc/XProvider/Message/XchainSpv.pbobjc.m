// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xchain_spv.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "XchainSpv.pbobjc.h"
#import "Xchain.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - XchainSpvRoot

@implementation XchainSpvRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - XchainSpvRoot_FileDescriptor

static GPBFileDescriptor *XchainSpvRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ReturnCode

GPBEnumDescriptor *ReturnCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Returnsuccess\000Internalerr\000Filenotexist\000P"
        "aramerr\000Httprequertfail\000Httpresponsefail"
        "\000Accountnotexist\000Pwnotexist\000Pwexist\000Notl"
        "ogin\000Connectnodefail\000Utxonotenough\000Addre"
        "ssinvalid\000Feeinvalid\000Connectrefused\000Utxo"
        "encrypterr\000Feenotenougn\000Paramsinvalid\000Tx"
        "signerr\000Reposttxerr\000Blockchainnotexist\000S"
        "ervererr\000";
    static const int32_t values[] = {
        ReturnCode_Returnsuccess,
        ReturnCode_Internalerr,
        ReturnCode_Filenotexist,
        ReturnCode_Paramerr,
        ReturnCode_Httprequertfail,
        ReturnCode_Httpresponsefail,
        ReturnCode_Accountnotexist,
        ReturnCode_Pwnotexist,
        ReturnCode_Pwexist,
        ReturnCode_Notlogin,
        ReturnCode_Connectnodefail,
        ReturnCode_Utxonotenough,
        ReturnCode_Addressinvalid,
        ReturnCode_Feeinvalid,
        ReturnCode_Connectrefused,
        ReturnCode_Utxoencrypterr,
        ReturnCode_Feenotenougn,
        ReturnCode_Paramsinvalid,
        ReturnCode_Txsignerr,
        ReturnCode_Reposttxerr,
        ReturnCode_Blockchainnotexist,
        ReturnCode_Servererr,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReturnCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReturnCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ReturnCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReturnCode_Returnsuccess:
    case ReturnCode_Internalerr:
    case ReturnCode_Filenotexist:
    case ReturnCode_Paramerr:
    case ReturnCode_Httprequertfail:
    case ReturnCode_Httpresponsefail:
    case ReturnCode_Accountnotexist:
    case ReturnCode_Pwnotexist:
    case ReturnCode_Pwexist:
    case ReturnCode_Notlogin:
    case ReturnCode_Connectnodefail:
    case ReturnCode_Utxonotenough:
    case ReturnCode_Addressinvalid:
    case ReturnCode_Feeinvalid:
    case ReturnCode_Connectrefused:
    case ReturnCode_Utxoencrypterr:
    case ReturnCode_Feenotenougn:
    case ReturnCode_Paramsinvalid:
    case ReturnCode_Txsignerr:
    case ReturnCode_Reposttxerr:
    case ReturnCode_Blockchainnotexist:
    case ReturnCode_Servererr:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ECDSAAccount

@implementation ECDSAAccount

@dynamic entropyByte;
@dynamic mnemonic;
@dynamic jsonPrivateKey;
@dynamic jsonPublicKey;
@dynamic address;

typedef struct ECDSAAccount__storage_ {
  uint32_t _has_storage_[1];
  NSData *entropyByte;
  NSString *mnemonic;
  NSString *jsonPrivateKey;
  NSString *jsonPublicKey;
  NSString *address;
} ECDSAAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entropyByte",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccount_FieldNumber_EntropyByte,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECDSAAccount__storage_, entropyByte),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "mnemonic",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccount_FieldNumber_Mnemonic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECDSAAccount__storage_, mnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonPrivateKey",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccount_FieldNumber_JsonPrivateKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ECDSAAccount__storage_, jsonPrivateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonPublicKey",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccount_FieldNumber_JsonPublicKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ECDSAAccount__storage_, jsonPublicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccount_FieldNumber_Address,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ECDSAAccount__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECDSAAccount class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECDSAAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\003\016\000\004\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ECDSAInfo

@implementation ECDSAInfo

@dynamic entropyByte;
@dynamic mnemonic;
@dynamic address;

typedef struct ECDSAInfo__storage_ {
  uint32_t _has_storage_[1];
  NSData *entropyByte;
  NSString *mnemonic;
  NSString *address;
} ECDSAInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entropyByte",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAInfo_FieldNumber_EntropyByte,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECDSAInfo__storage_, entropyByte),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "mnemonic",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAInfo_FieldNumber_Mnemonic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECDSAInfo__storage_, mnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAInfo_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ECDSAInfo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECDSAInfo class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECDSAInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ECDSAAccountFromCloud

@implementation ECDSAAccountFromCloud

@dynamic address;
@dynamic jsonEncryptedPrivateKey;
@dynamic encryptedMnemonic;

typedef struct ECDSAAccountFromCloud__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *jsonEncryptedPrivateKey;
  NSString *encryptedMnemonic;
} ECDSAAccountFromCloud__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccountFromCloud_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECDSAAccountFromCloud__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonEncryptedPrivateKey",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccountFromCloud_FieldNumber_JsonEncryptedPrivateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECDSAAccountFromCloud__storage_, jsonEncryptedPrivateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptedMnemonic",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccountFromCloud_FieldNumber_EncryptedMnemonic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ECDSAAccountFromCloud__storage_, encryptedMnemonic),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECDSAAccountFromCloud class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECDSAAccountFromCloud__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\027\000\003\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ECDSAAccountToCloud

@implementation ECDSAAccountToCloud

@dynamic address;
@dynamic jsonEncryptedPrivateKey;
@dynamic encryptedMnemonic;
@dynamic password;

typedef struct ECDSAAccountToCloud__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *jsonEncryptedPrivateKey;
  NSString *encryptedMnemonic;
  NSString *password;
} ECDSAAccountToCloud__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccountToCloud_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECDSAAccountToCloud__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonEncryptedPrivateKey",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccountToCloud_FieldNumber_JsonEncryptedPrivateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECDSAAccountToCloud__storage_, jsonEncryptedPrivateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptedMnemonic",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccountToCloud_FieldNumber_EncryptedMnemonic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ECDSAAccountToCloud__storage_, encryptedMnemonic),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = ECDSAAccountToCloud_FieldNumber_Password,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ECDSAAccountToCloud__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECDSAAccountToCloud class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECDSAAccountToCloud__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\027\000\003\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Node

@implementation Node

@dynamic host;
@dynamic utxoQueryURL;
@dynamic txPostURL;
@dynamic balanceQueryURL;

typedef struct Node__storage_ {
  uint32_t _has_storage_[1];
  NSData *host;
  NSData *utxoQueryURL;
  NSData *txPostURL;
  NSData *balanceQueryURL;
} Node__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_Host,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Node__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "utxoQueryURL",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_UtxoQueryURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Node__storage_, utxoQueryURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txPostURL",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_TxPostURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Node__storage_, txPostURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balanceQueryURL",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_BalanceQueryURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Node__storage_, balanceQueryURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Node class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Node__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\n!!\000\003\007!!\000\004\r!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxInputs

@implementation TxInputs

@dynamic txInputListArray, txInputListArray_Count;

typedef struct TxInputs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txInputListArray;
} TxInputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txInputListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxInput),
        .number = TxInputs_FieldNumber_TxInputListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxInputs__storage_, txInputListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxInputs class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxInputs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000txInputList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxOutputs

@implementation TxOutputs

@dynamic txOutputListArray, txOutputListArray_Count;

typedef struct TxOutputs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txOutputListArray;
} TxOutputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txOutputListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxOutput),
        .number = TxOutputs_FieldNumber_TxOutputListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxOutputs__storage_, txOutputListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxOutputs class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxOutputs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000txOutputList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UTXOs

@implementation UTXOs

@dynamic uTxolistArray, uTxolistArray_Count;

typedef struct UTXOs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *uTxolistArray;
} UTXOs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uTxolistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UTXO),
        .number = UTXOs_FieldNumber_UTxolistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UTXOs__storage_, uTxolistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UTXOs class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UTXOs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000uTXOList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UTXO

@implementation UTXO

@dynamic amount;
@dynamic toAddr;
@dynamic toPubkey;
@dynamic refTxid;
@dynamic refOffset;

typedef struct UTXO__storage_ {
  uint32_t _has_storage_[1];
  int32_t refOffset;
  NSData *amount;
  NSData *toAddr;
  NSData *toPubkey;
  NSData *refTxid;
} UTXO__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = UTXO_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UTXO__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddr",
        .dataTypeSpecific.className = NULL,
        .number = UTXO_FieldNumber_ToAddr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UTXO__storage_, toAddr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toPubkey",
        .dataTypeSpecific.className = NULL,
        .number = UTXO_FieldNumber_ToPubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UTXO__storage_, toPubkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refTxid",
        .dataTypeSpecific.className = NULL,
        .number = UTXO_FieldNumber_RefTxid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UTXO__storage_, refTxid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refOffset",
        .dataTypeSpecific.className = NULL,
        .number = UTXO_FieldNumber_RefOffset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UTXO__storage_, refOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UTXO class]
                                     rootClass:[XchainSpvRoot class]
                                          file:XchainSpvRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UTXO__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\006\000\003\010\000\004\007\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
