// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xchain.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Xchain.pbobjc.h"
#import "Chainedbft.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - XchainRoot

@implementation XchainRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - XchainRoot_FileDescriptor

static GPBFileDescriptor *XchainRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum XChainErrorEnum

GPBEnumDescriptor *XChainErrorEnum_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000UnknowError\000ConnectRefuse\000NotEno"
        "ughUtxoError\000UtxovmAlreadyUnconfirmError"
        "\000UtxovmNotFoundError\000InputOutputNotEqual"
        "Error\000TxNotFoundError\000TxSignError\000Blockc"
        "hainNotexist\000ValidateError\000CannotSyncBlo"
        "ckError\000ConfirmBlockError\000UtxovmPlayErro"
        "r\000WalkError\000NotReadyError\000BlockExistErro"
        "r\000RootBlockExistError\000TxDuplicateError\000S"
        "erviceRefusedError\000TxdataSignError\000TxSle"
        "Error\000TxFeeNotEnoughError\000UtxoSignError\000"
        "DposQueryError\000RwsetInvalidError\000RwaclIn"
        "validError\000GasNotEnoughError\000TxVersionIn"
        "validError\000ComplianceCheckNotApproved\000Ac"
        "countContractStatusError\000TxVerificationE"
        "rror\000";
    static const int32_t values[] = {
        XChainErrorEnum_Success,
        XChainErrorEnum_UnknowError,
        XChainErrorEnum_ConnectRefuse,
        XChainErrorEnum_NotEnoughUtxoError,
        XChainErrorEnum_UtxovmAlreadyUnconfirmError,
        XChainErrorEnum_UtxovmNotFoundError,
        XChainErrorEnum_InputOutputNotEqualError,
        XChainErrorEnum_TxNotFoundError,
        XChainErrorEnum_TxSignError,
        XChainErrorEnum_BlockchainNotexist,
        XChainErrorEnum_ValidateError,
        XChainErrorEnum_CannotSyncBlockError,
        XChainErrorEnum_ConfirmBlockError,
        XChainErrorEnum_UtxovmPlayError,
        XChainErrorEnum_WalkError,
        XChainErrorEnum_NotReadyError,
        XChainErrorEnum_BlockExistError,
        XChainErrorEnum_RootBlockExistError,
        XChainErrorEnum_TxDuplicateError,
        XChainErrorEnum_ServiceRefusedError,
        XChainErrorEnum_TxdataSignError,
        XChainErrorEnum_TxSleError,
        XChainErrorEnum_TxFeeNotEnoughError,
        XChainErrorEnum_UtxoSignError,
        XChainErrorEnum_DposQueryError,
        XChainErrorEnum_RwsetInvalidError,
        XChainErrorEnum_RwaclInvalidError,
        XChainErrorEnum_GasNotEnoughError,
        XChainErrorEnum_TxVersionInvalidError,
        XChainErrorEnum_ComplianceCheckNotApproved,
        XChainErrorEnum_AccountContractStatusError,
        XChainErrorEnum_TxVerificationError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(XChainErrorEnum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:XChainErrorEnum_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL XChainErrorEnum_IsValidValue(int32_t value__) {
  switch (value__) {
    case XChainErrorEnum_Success:
    case XChainErrorEnum_UnknowError:
    case XChainErrorEnum_ConnectRefuse:
    case XChainErrorEnum_NotEnoughUtxoError:
    case XChainErrorEnum_UtxovmAlreadyUnconfirmError:
    case XChainErrorEnum_UtxovmNotFoundError:
    case XChainErrorEnum_InputOutputNotEqualError:
    case XChainErrorEnum_TxNotFoundError:
    case XChainErrorEnum_TxSignError:
    case XChainErrorEnum_BlockchainNotexist:
    case XChainErrorEnum_ValidateError:
    case XChainErrorEnum_CannotSyncBlockError:
    case XChainErrorEnum_ConfirmBlockError:
    case XChainErrorEnum_UtxovmPlayError:
    case XChainErrorEnum_WalkError:
    case XChainErrorEnum_NotReadyError:
    case XChainErrorEnum_BlockExistError:
    case XChainErrorEnum_RootBlockExistError:
    case XChainErrorEnum_TxDuplicateError:
    case XChainErrorEnum_ServiceRefusedError:
    case XChainErrorEnum_TxdataSignError:
    case XChainErrorEnum_TxSleError:
    case XChainErrorEnum_TxFeeNotEnoughError:
    case XChainErrorEnum_UtxoSignError:
    case XChainErrorEnum_DposQueryError:
    case XChainErrorEnum_RwsetInvalidError:
    case XChainErrorEnum_RwaclInvalidError:
    case XChainErrorEnum_GasNotEnoughError:
    case XChainErrorEnum_TxVersionInvalidError:
    case XChainErrorEnum_ComplianceCheckNotApproved:
    case XChainErrorEnum_AccountContractStatusError:
    case XChainErrorEnum_TxVerificationError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TransactionStatus

GPBEnumDescriptor *TransactionStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Undefine\000Noexist\000Confirm\000Furcation\000Uncon"
        "firm\000";
    static const int32_t values[] = {
        TransactionStatus_Undefine,
        TransactionStatus_Noexist,
        TransactionStatus_Confirm,
        TransactionStatus_Furcation,
        TransactionStatus_Unconfirm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransactionStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransactionStatus_Undefine:
    case TransactionStatus_Noexist:
    case TransactionStatus_Confirm:
    case TransactionStatus_Furcation:
    case TransactionStatus_Unconfirm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PermissionRule

GPBEnumDescriptor *PermissionRule_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Null\000SignThreshold\000SignAkset\000SignRate\000Si"
        "gnSum\000CaServer\000CommunityVote\000";
    static const int32_t values[] = {
        PermissionRule_Null,
        PermissionRule_SignThreshold,
        PermissionRule_SignAkset,
        PermissionRule_SignRate,
        PermissionRule_SignSum,
        PermissionRule_CaServer,
        PermissionRule_CommunityVote,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PermissionRule)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PermissionRule_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PermissionRule_IsValidValue(int32_t value__) {
  switch (value__) {
    case PermissionRule_Null:
    case PermissionRule_SignThreshold:
    case PermissionRule_SignAkset:
    case PermissionRule_SignRate:
    case PermissionRule_SignSum:
    case PermissionRule_CaServer:
    case PermissionRule_CommunityVote:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResourceType

GPBEnumDescriptor *ResourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Cpu\000Memory\000Disk\000Xfee\000";
    static const int32_t values[] = {
        ResourceType_Cpu,
        ResourceType_Memory,
        ResourceType_Disk,
        ResourceType_Xfee,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResourceType_Cpu:
    case ResourceType_Memory:
    case ResourceType_Disk:
    case ResourceType_Xfee:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Header

@implementation Header

@dynamic logid;
@dynamic fromNode;
@dynamic error;

typedef struct Header__storage_ {
  uint32_t _has_storage_[1];
  XChainErrorEnum error;
  NSString *logid;
  NSString *fromNode;
} Header__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logid",
        .dataTypeSpecific.className = NULL,
        .number = Header_FieldNumber_Logid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Header__storage_, logid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromNode",
        .dataTypeSpecific.className = NULL,
        .number = Header_FieldNumber_FromNode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Header__storage_, fromNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = XChainErrorEnum_EnumDescriptor,
        .number = Header_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Header__storage_, error),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Header class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Header__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Header_Error_RawValue(Header *message) {
  GPBDescriptor *descriptor = [Header descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Header_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetHeader_Error_RawValue(Header *message, int32_t value) {
  GPBDescriptor *descriptor = [Header descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Header_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - TxDataAccount

@implementation TxDataAccount

@dynamic address;
@dynamic amount;
@dynamic frozenHeight;

typedef struct TxDataAccount__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *amount;
  int64_t frozenHeight;
} TxDataAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = TxDataAccount_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxDataAccount__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = TxDataAccount_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxDataAccount__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "frozenHeight",
        .dataTypeSpecific.className = NULL,
        .number = TxDataAccount_FieldNumber_FrozenHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxDataAccount__storage_, frozenHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxDataAccount class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxDataAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxData

@implementation TxData

@dynamic hasHeader, header;
@dynamic txid;
@dynamic bcname;
@dynamic fromAddr;
@dynamic fromPubkey;
@dynamic fromScrkey;
@dynamic userSign;
@dynamic accountArray, accountArray_Count;
@dynamic nonce;
@dynamic timestamp;
@dynamic desc;
@dynamic version;

typedef struct TxData__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  NSData *txid;
  NSString *bcname;
  NSString *fromAddr;
  NSString *fromPubkey;
  NSString *fromScrkey;
  NSMutableArray *accountArray;
  NSString *nonce;
  NSData *desc;
  Header *header;
  NSData *userSign;
  int64_t timestamp;
} TxData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxData__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_Bcname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxData__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromAddr",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_FromAddr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TxData__storage_, fromAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromPubkey",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_FromPubkey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TxData__storage_, fromPubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromScrkey",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_FromScrkey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TxData__storage_, fromScrkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxDataAccount),
        .number = TxData_FieldNumber_AccountArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxData__storage_, accountArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_Nonce,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TxData__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_Timestamp,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TxData__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_Desc,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TxData__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = TxData_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxData__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userSign",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_UserSign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TxData__storage_, userSign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = TxData_FieldNumber_Version,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(TxData__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxData class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxStatus

@implementation TxStatus

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic txid;
@dynamic status;
@dynamic distance;
@dynamic hasTx, tx;

typedef struct TxStatus__storage_ {
  uint32_t _has_storage_[1];
  TransactionStatus status;
  Header *header;
  NSString *bcname;
  NSData *txid;
  Transaction *tx;
  int64_t distance;
} TxStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = TxStatus_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxStatus__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = TxStatus_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxStatus__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = TxStatus_FieldNumber_Txid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxStatus__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = TransactionStatus_EnumDescriptor,
        .number = TxStatus_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TxStatus__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "distance",
        .dataTypeSpecific.className = NULL,
        .number = TxStatus_FieldNumber_Distance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TxStatus__storage_, distance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tx",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TxStatus_FieldNumber_Tx,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TxStatus__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TxStatus_Status_RawValue(TxStatus *message) {
  GPBDescriptor *descriptor = [TxStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TxStatus_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetTxStatus_Status_RawValue(TxStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [TxStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TxStatus_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - BatchTxs

@implementation BatchTxs

@dynamic hasHeader, header;
@dynamic txsArray, txsArray_Count;

typedef struct BatchTxs__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *txsArray;
} BatchTxs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = BatchTxs_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchTxs__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxStatus),
        .number = BatchTxs_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchTxs__storage_, txsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchTxs class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchTxs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000Txs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic blockid;
@dynamic status;
@dynamic hasBlock, block;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  Block_EBlockStatus status;
  Header *header;
  NSString *bcname;
  NSData *blockid;
  InternalBlock *block;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = Block_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Block__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockid",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Blockid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Block__storage_, blockid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = Block_EBlockStatus_EnumDescriptor,
        .number = Block_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Block__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(InternalBlock),
        .number = Block_FieldNumber_Block,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Block__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Block_Status_RawValue(Block *message) {
  GPBDescriptor *descriptor = [Block descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Block_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetBlock_Status_RawValue(Block *message, int32_t value) {
  GPBDescriptor *descriptor = [Block descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Block_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Block_EBlockStatus

GPBEnumDescriptor *Block_EBlockStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Error\000Trunk\000Branch\000Noexist\000";
    static const int32_t values[] = {
        Block_EBlockStatus_Error,
        Block_EBlockStatus_Trunk,
        Block_EBlockStatus_Branch,
        Block_EBlockStatus_Noexist,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Block_EBlockStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Block_EBlockStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Block_EBlockStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case Block_EBlockStatus_Error:
    case Block_EBlockStatus_Trunk:
    case Block_EBlockStatus_Branch:
    case Block_EBlockStatus_Noexist:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BlockID

@implementation BlockID

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic blockid;
@dynamic needContent;

typedef struct BlockID__storage_ {
  uint32_t _has_storage_[1];
  NSString *bcname;
  NSData *blockid;
  Header *header;
} BlockID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = BlockID_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockID__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockid",
        .dataTypeSpecific.className = NULL,
        .number = BlockID_FieldNumber_Blockid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockID__storage_, blockid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "needContent",
        .dataTypeSpecific.className = NULL,
        .number = BlockID_FieldNumber_NeedContent,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = BlockID_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockID__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockID class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockID__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeight

@implementation BlockHeight

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic height;

typedef struct BlockHeight__storage_ {
  uint32_t _has_storage_[1];
  NSString *bcname;
  Header *header;
  int64_t height;
} BlockHeight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeight_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeight__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeight_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeight__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = BlockHeight_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeight__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeight class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeight__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommonReply

@implementation CommonReply

@dynamic hasHeader, header;

typedef struct CommonReply__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
} CommonReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = CommonReply_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommonReply__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommonReply class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommonReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommonIn

@implementation CommonIn

@dynamic hasHeader, header;

typedef struct CommonIn__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
} CommonIn__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = CommonIn_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommonIn__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommonIn class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommonIn__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenDetail

@implementation TokenDetail

@dynamic bcname;
@dynamic balance;
@dynamic error;

typedef struct TokenDetail__storage_ {
  uint32_t _has_storage_[1];
  XChainErrorEnum error;
  NSString *bcname;
  NSString *balance;
} TokenDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = TokenDetail_FieldNumber_Bcname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenDetail__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = TokenDetail_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TokenDetail__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = XChainErrorEnum_EnumDescriptor,
        .number = TokenDetail_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TokenDetail__storage_, error),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenDetail class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TokenDetail_Error_RawValue(TokenDetail *message) {
  GPBDescriptor *descriptor = [TokenDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TokenDetail_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetTokenDetail_Error_RawValue(TokenDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [TokenDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TokenDetail_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AddressStatus

@implementation AddressStatus

@dynamic hasHeader, header;
@dynamic address;
@dynamic bcsArray, bcsArray_Count;

typedef struct AddressStatus__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *address;
  NSMutableArray *bcsArray;
} AddressStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = AddressStatus_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressStatus__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddressStatus_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressStatus__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bcsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TokenDetail),
        .number = AddressStatus_FieldNumber_BcsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressStatus__storage_, bcsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenFrozenDetail

@implementation TokenFrozenDetail

@dynamic balance;
@dynamic isFrozen;

typedef struct TokenFrozenDetail__storage_ {
  uint32_t _has_storage_[1];
  NSString *balance;
} TokenFrozenDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = TokenFrozenDetail_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenFrozenDetail__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isFrozen",
        .dataTypeSpecific.className = NULL,
        .number = TokenFrozenDetail_FieldNumber_IsFrozen,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenFrozenDetail class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenFrozenDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenFrozenDetails

@implementation TokenFrozenDetails

@dynamic bcname;
@dynamic tfdArray, tfdArray_Count;
@dynamic error;

typedef struct TokenFrozenDetails__storage_ {
  uint32_t _has_storage_[1];
  XChainErrorEnum error;
  NSString *bcname;
  NSMutableArray *tfdArray;
} TokenFrozenDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = TokenFrozenDetails_FieldNumber_Bcname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenFrozenDetails__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tfdArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TokenFrozenDetail),
        .number = TokenFrozenDetails_FieldNumber_TfdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenFrozenDetails__storage_, tfdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = XChainErrorEnum_EnumDescriptor,
        .number = TokenFrozenDetails_FieldNumber_Error,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TokenFrozenDetails__storage_, error),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenFrozenDetails class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenFrozenDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TokenFrozenDetails_Error_RawValue(TokenFrozenDetails *message) {
  GPBDescriptor *descriptor = [TokenFrozenDetails descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TokenFrozenDetails_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetTokenFrozenDetails_Error_RawValue(TokenFrozenDetails *message, int32_t value) {
  GPBDescriptor *descriptor = [TokenFrozenDetails descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TokenFrozenDetails_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AddressBalanceStatus

@implementation AddressBalanceStatus

@dynamic hasHeader, header;
@dynamic address;
@dynamic tfdsArray, tfdsArray_Count;

typedef struct AddressBalanceStatus__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *address;
  NSMutableArray *tfdsArray;
} AddressBalanceStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = AddressBalanceStatus_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressBalanceStatus__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddressBalanceStatus_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressBalanceStatus__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tfdsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TokenFrozenDetails),
        .number = AddressBalanceStatus_FieldNumber_TfdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressBalanceStatus__storage_, tfdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressBalanceStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressBalanceStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxInput

@implementation TxInput

@dynamic refTxid;
@dynamic refOffset;
@dynamic fromAddr;
@dynamic amount;
@dynamic frozenHeight;

typedef struct TxInput__storage_ {
  uint32_t _has_storage_[1];
  int32_t refOffset;
  NSData *refTxid;
  NSData *fromAddr;
  NSData *amount;
  int64_t frozenHeight;
} TxInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "refTxid",
        .dataTypeSpecific.className = NULL,
        .number = TxInput_FieldNumber_RefTxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxInput__storage_, refTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refOffset",
        .dataTypeSpecific.className = NULL,
        .number = TxInput_FieldNumber_RefOffset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxInput__storage_, refOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fromAddr",
        .dataTypeSpecific.className = NULL,
        .number = TxInput_FieldNumber_FromAddr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxInput__storage_, fromAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = TxInput_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TxInput__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frozenHeight",
        .dataTypeSpecific.className = NULL,
        .number = TxInput_FieldNumber_FrozenHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TxInput__storage_, frozenHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxInput class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxOutput

@implementation TxOutput

@dynamic amount;
@dynamic toAddr;
@dynamic frozenHeight;

typedef struct TxOutput__storage_ {
  uint32_t _has_storage_[1];
  NSData *amount;
  NSData *toAddr;
  int64_t frozenHeight;
} TxOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = TxOutput_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxOutput__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddr",
        .dataTypeSpecific.className = NULL,
        .number = TxOutput_FieldNumber_ToAddr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxOutput__storage_, toAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frozenHeight",
        .dataTypeSpecific.className = NULL,
        .number = TxOutput_FieldNumber_FrozenHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxOutput__storage_, frozenHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxOutput class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxOutput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - XuperSignature

@implementation XuperSignature

@dynamic publicKeysArray, publicKeysArray_Count;
@dynamic signature;

typedef struct XuperSignature__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *publicKeysArray;
  NSData *signature;
} XuperSignature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = XuperSignature_FieldNumber_PublicKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(XuperSignature__storage_, publicKeysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = XuperSignature_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(XuperSignature__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[XuperSignature class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(XuperSignature__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic txid;
@dynamic blockid;
@dynamic txInputsArray, txInputsArray_Count;
@dynamic txOutputsArray, txOutputsArray_Count;
@dynamic desc;
@dynamic coinbase;
@dynamic nonce;
@dynamic timestamp;
@dynamic version;
@dynamic autogen;
@dynamic txInputsExtArray, txInputsExtArray_Count;
@dynamic txOutputsExtArray, txOutputsExtArray_Count;
@dynamic contractRequestsArray, contractRequestsArray_Count;
@dynamic initiator;
@dynamic authRequireArray, authRequireArray_Count;
@dynamic initiatorSignsArray, initiatorSignsArray_Count;
@dynamic authRequireSignsArray, authRequireSignsArray_Count;
@dynamic receivedTimestamp;
@dynamic hasXuperSign, xuperSign;
@dynamic hasModifyBlock, modifyBlock;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  NSData *txid;
  NSData *blockid;
  NSMutableArray *txInputsArray;
  NSMutableArray *txOutputsArray;
  NSData *desc;
  NSString *nonce;
  NSMutableArray *txInputsExtArray;
  NSMutableArray *txOutputsExtArray;
  NSMutableArray *contractRequestsArray;
  NSString *initiator;
  NSMutableArray *authRequireArray;
  NSMutableArray *initiatorSignsArray;
  NSMutableArray *authRequireSignsArray;
  XuperSignature *xuperSign;
  ModifyBlock *modifyBlock;
  int64_t timestamp;
  int64_t receivedTimestamp;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockid",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Blockid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txInputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxInput),
        .number = Transaction_FieldNumber_TxInputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, txInputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txOutputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxOutput),
        .number = Transaction_FieldNumber_TxOutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, txOutputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "coinbase",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Coinbase,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Nonce,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Version,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "autogen",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Autogen,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "txInputsExtArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxInputExt),
        .number = Transaction_FieldNumber_TxInputsExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, txInputsExtArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txOutputsExtArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxOutputExt),
        .number = Transaction_FieldNumber_TxOutputsExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, txOutputsExtArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contractRequestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeRequest),
        .number = Transaction_FieldNumber_ContractRequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, contractRequestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initiator",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Initiator,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Transaction__storage_, initiator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authRequireArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_AuthRequireArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, authRequireArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initiatorSignsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SignatureInfo),
        .number = Transaction_FieldNumber_InitiatorSignsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, initiatorSignsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authRequireSignsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SignatureInfo),
        .number = Transaction_FieldNumber_AuthRequireSignsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, authRequireSignsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receivedTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_ReceivedTimestamp,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Transaction__storage_, receivedTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "xuperSign",
        .dataTypeSpecific.className = GPBStringifySymbol(XuperSignature),
        .number = Transaction_FieldNumber_XuperSign,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Transaction__storage_, xuperSign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modifyBlock",
        .dataTypeSpecific.className = GPBStringifySymbol(ModifyBlock),
        .number = Transaction_FieldNumber_ModifyBlock,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Transaction__storage_, modifyBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LedgerMeta

@implementation LedgerMeta

@dynamic rootBlockid;
@dynamic tipBlockid;
@dynamic trunkHeight;

typedef struct LedgerMeta__storage_ {
  uint32_t _has_storage_[1];
  NSData *rootBlockid;
  NSData *tipBlockid;
  int64_t trunkHeight;
} LedgerMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rootBlockid",
        .dataTypeSpecific.className = NULL,
        .number = LedgerMeta_FieldNumber_RootBlockid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LedgerMeta__storage_, rootBlockid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tipBlockid",
        .dataTypeSpecific.className = NULL,
        .number = LedgerMeta_FieldNumber_TipBlockid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LedgerMeta__storage_, tipBlockid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "trunkHeight",
        .dataTypeSpecific.className = NULL,
        .number = LedgerMeta_FieldNumber_TrunkHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LedgerMeta__storage_, trunkHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LedgerMeta class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LedgerMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UtxoMeta

@implementation UtxoMeta

@dynamic latestBlockid;
@dynamic lockKeyListArray, lockKeyListArray_Count;
@dynamic utxoTotal;
@dynamic avgDelay;
@dynamic unconfirmTxAmount;
@dynamic maxBlockSize;
@dynamic reservedContractsArray, reservedContractsArray_Count;
@dynamic hasForbiddenContract, forbiddenContract;
@dynamic newAccountResourceAmount;
@dynamic irreversibleBlockHeight;
@dynamic irreversibleSlideWindow;

typedef struct UtxoMeta__storage_ {
  uint32_t _has_storage_[1];
  NSData *latestBlockid;
  NSMutableArray *lockKeyListArray;
  NSString *utxoTotal;
  NSMutableArray *reservedContractsArray;
  InvokeRequest *forbiddenContract;
  int64_t avgDelay;
  int64_t unconfirmTxAmount;
  int64_t maxBlockSize;
  int64_t newAccountResourceAmount;
  int64_t irreversibleBlockHeight;
  int64_t irreversibleSlideWindow;
} UtxoMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latestBlockid",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_LatestBlockid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, latestBlockid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "lockKeyListArray",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_LockKeyListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, lockKeyListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "utxoTotal",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_UtxoTotal,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, utxoTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avgDelay",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_AvgDelay,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, avgDelay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unconfirmTxAmount",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_UnconfirmTxAmount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, unconfirmTxAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maxBlockSize",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_MaxBlockSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, maxBlockSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "reservedContractsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeRequest),
        .number = UtxoMeta_FieldNumber_ReservedContractsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, reservedContractsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forbiddenContract",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeRequest),
        .number = UtxoMeta_FieldNumber_ForbiddenContract,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, forbiddenContract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newAccountResourceAmount",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_NewAccountResourceAmount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, newAccountResourceAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "irreversibleBlockHeight",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_IrreversibleBlockHeight,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, irreversibleBlockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "irreversibleSlideWindow",
        .dataTypeSpecific.className = NULL,
        .number = UtxoMeta_FieldNumber_IrreversibleSlideWindow,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UtxoMeta__storage_, irreversibleSlideWindow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UtxoMeta class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UtxoMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\004\010\000\005\021\000\n\027\000\013\027\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InternalBlock

@implementation InternalBlock

@dynamic version;
@dynamic nonce;
@dynamic blockid;
@dynamic preHash;
@dynamic proposer;
@dynamic sign;
@dynamic pubkey;
@dynamic merkleRoot;
@dynamic height;
@dynamic timestamp;
@dynamic transactionsArray, transactionsArray_Count;
@dynamic txCount;
@dynamic merkleTreeArray, merkleTreeArray_Count;
@dynamic curTerm;
@dynamic curBlockNum;
@dynamic failedTxs, failedTxs_Count;
@dynamic targetBits;
@dynamic hasJustify, justify;
@dynamic inTrunk;
@dynamic nextHash;

typedef struct InternalBlock__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  int32_t nonce;
  int32_t txCount;
  int32_t targetBits;
  NSData *blockid;
  NSData *preHash;
  NSData *proposer;
  NSData *sign;
  NSData *pubkey;
  NSData *merkleRoot;
  NSMutableArray *transactionsArray;
  NSMutableArray *merkleTreeArray;
  NSData *nextHash;
  NSMutableDictionary *failedTxs;
  QuorumCert *justify;
  int64_t height;
  int64_t timestamp;
  int64_t curTerm;
  int64_t curBlockNum;
} InternalBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Nonce,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockid",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Blockid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, blockid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "preHash",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_PreHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, preHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposer",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Proposer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, proposer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Sign,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Pubkey,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "merkleRoot",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_MerkleRoot,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, merkleRoot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Height,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_Timestamp,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = InternalBlock_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txCount",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_TxCount,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, txCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "merkleTreeArray",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_MerkleTreeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, merkleTreeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "inTrunk",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_InTrunk,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "nextHash",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_NextHash,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, nextHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "curTerm",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_CurTerm,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, curTerm),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "curBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_CurBlockNum,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, curBlockNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "failedTxs",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_FailedTxs,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, failedTxs),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetBits",
        .dataTypeSpecific.className = NULL,
        .number = InternalBlock_FieldNumber_TargetBits,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, targetBits),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "justify",
        .dataTypeSpecific.className = GPBStringifySymbol(QuorumCert),
        .number = InternalBlock_FieldNumber_Justify,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(InternalBlock__storage_, justify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InternalBlock class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InternalBlock__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\020\007\000\021\013\000\023\n\000\024G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BCStatus

@implementation BCStatus

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic hasMeta, meta;
@dynamic hasBlock, block;
@dynamic hasUtxoMeta, utxoMeta;
@dynamic branchBlockidArray, branchBlockidArray_Count;

typedef struct BCStatus__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  LedgerMeta *meta;
  InternalBlock *block;
  UtxoMeta *utxoMeta;
  NSMutableArray *branchBlockidArray;
} BCStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = BCStatus_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BCStatus__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = BCStatus_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BCStatus__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(LedgerMeta),
        .number = BCStatus_FieldNumber_Meta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BCStatus__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(InternalBlock),
        .number = BCStatus_FieldNumber_Block,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BCStatus__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "utxoMeta",
        .dataTypeSpecific.className = GPBStringifySymbol(UtxoMeta),
        .number = BCStatus_FieldNumber_UtxoMeta,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BCStatus__storage_, utxoMeta),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "branchBlockidArray",
        .dataTypeSpecific.className = NULL,
        .number = BCStatus_FieldNumber_BranchBlockidArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BCStatus__storage_, branchBlockidArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BCStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BCStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\005\010\000\006\000branchBlockid\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BCTipStatus

@implementation BCTipStatus

@dynamic hasHeader, header;
@dynamic isTrunkTip;

typedef struct BCTipStatus__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
} BCTipStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = BCTipStatus_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BCTipStatus__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isTrunkTip",
        .dataTypeSpecific.className = NULL,
        .number = BCTipStatus_FieldNumber_IsTrunkTip,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BCTipStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BCTipStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockChains

@implementation BlockChains

@dynamic hasHeader, header;
@dynamic blockchainsArray, blockchainsArray_Count;

typedef struct BlockChains__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *blockchainsArray;
} BlockChains__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = BlockChains_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockChains__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockchainsArray",
        .dataTypeSpecific.className = NULL,
        .number = BlockChains_FieldNumber_BlockchainsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockChains__storage_, blockchainsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockChains class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockChains__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Speeds

@implementation Speeds

@dynamic sumSpeeds, sumSpeeds_Count;
@dynamic bcSpeeds, bcSpeeds_Count;

typedef struct Speeds__storage_ {
  uint32_t _has_storage_[1];
  GPBStringDoubleDictionary *sumSpeeds;
  NSMutableDictionary *bcSpeeds;
} Speeds__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sumSpeeds",
        .dataTypeSpecific.className = NULL,
        .number = Speeds_FieldNumber_SumSpeeds,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Speeds__storage_, sumSpeeds),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "bcSpeeds",
        .dataTypeSpecific.className = GPBStringifySymbol(BCSpeeds),
        .number = Speeds_FieldNumber_BcSpeeds,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Speeds__storage_, bcSpeeds),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Speeds class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Speeds__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001I\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BCSpeeds

@implementation BCSpeeds

@dynamic bcSpeed, bcSpeed_Count;

typedef struct BCSpeeds__storage_ {
  uint32_t _has_storage_[1];
  GPBStringDoubleDictionary *bcSpeed;
} BCSpeeds__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bcSpeed",
        .dataTypeSpecific.className = NULL,
        .number = BCSpeeds_FieldNumber_BcSpeed,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BCSpeeds__storage_, bcSpeed),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BCSpeeds class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BCSpeeds__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemsStatus

@implementation SystemsStatus

@dynamic hasHeader, header;
@dynamic bcsStatusArray, bcsStatusArray_Count;
@dynamic hasSpeeds, speeds;
@dynamic peerUrlsArray, peerUrlsArray_Count;

typedef struct SystemsStatus__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *bcsStatusArray;
  Speeds *speeds;
  NSMutableArray *peerUrlsArray;
} SystemsStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = SystemsStatus_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemsStatus__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcsStatusArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BCStatus),
        .number = SystemsStatus_FieldNumber_BcsStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SystemsStatus__storage_, bcsStatusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speeds",
        .dataTypeSpecific.className = GPBStringifySymbol(Speeds),
        .number = SystemsStatus_FieldNumber_Speeds,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemsStatus__storage_, speeds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peerUrlsArray",
        .dataTypeSpecific.className = NULL,
        .number = SystemsStatus_FieldNumber_PeerUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SystemsStatus__storage_, peerUrlsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemsStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemsStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\000peerUrls\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemsStatusReply

@implementation SystemsStatusReply

@dynamic hasHeader, header;
@dynamic hasSystemsStatus, systemsStatus;

typedef struct SystemsStatusReply__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  SystemsStatus *systemsStatus;
} SystemsStatusReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = SystemsStatusReply_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemsStatusReply__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "systemsStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(SystemsStatus),
        .number = SystemsStatusReply_FieldNumber_SystemsStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemsStatusReply__storage_, systemsStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemsStatusReply class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemsStatusReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RawUrl

@implementation RawUrl

@dynamic hasHeader, header;
@dynamic rawURL;

typedef struct RawUrl__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *rawURL;
} RawUrl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = RawUrl_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RawUrl__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rawURL",
        .dataTypeSpecific.className = NULL,
        .number = RawUrl_FieldNumber_RawURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RawUrl__storage_, rawURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RawUrl class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RawUrl__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\004!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Utxo

@implementation Utxo

@dynamic amount;
@dynamic toAddr;
@dynamic toPubkey;
@dynamic refTxid;
@dynamic refOffset;

typedef struct Utxo__storage_ {
  uint32_t _has_storage_[1];
  int32_t refOffset;
  NSData *amount;
  NSData *toAddr;
  NSData *toPubkey;
  NSData *refTxid;
} Utxo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Utxo__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddr",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_ToAddr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Utxo__storage_, toAddr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toPubkey",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_ToPubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Utxo__storage_, toPubkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refTxid",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_RefTxid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Utxo__storage_, refTxid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refOffset",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_RefOffset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Utxo__storage_, refOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Utxo class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Utxo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\006\000\003\010\000\004\007\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UtxoInput

@implementation UtxoInput

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic address;
@dynamic publickey;
@dynamic totalNeed;
@dynamic userSign;
@dynamic needLock;

typedef struct UtxoInput__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *address;
  NSString *publickey;
  NSString *totalNeed;
  NSData *userSign;
} UtxoInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = UtxoInput_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UtxoInput__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = UtxoInput_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UtxoInput__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = UtxoInput_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UtxoInput__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publickey",
        .dataTypeSpecific.className = NULL,
        .number = UtxoInput_FieldNumber_Publickey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UtxoInput__storage_, publickey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalNeed",
        .dataTypeSpecific.className = NULL,
        .number = UtxoInput_FieldNumber_TotalNeed,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UtxoInput__storage_, totalNeed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userSign",
        .dataTypeSpecific.className = NULL,
        .number = UtxoInput_FieldNumber_UserSign,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UtxoInput__storage_, userSign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "needLock",
        .dataTypeSpecific.className = NULL,
        .number = UtxoInput_FieldNumber_NeedLock,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UtxoInput class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UtxoInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\005\t\000\007\010\000\010\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UtxoOutput

@implementation UtxoOutput

@dynamic hasHeader, header;
@dynamic utxoListArray, utxoListArray_Count;
@dynamic totalSelected;

typedef struct UtxoOutput__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *utxoListArray;
  NSString *totalSelected;
} UtxoOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = UtxoOutput_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UtxoOutput__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "utxoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Utxo),
        .number = UtxoOutput_FieldNumber_UtxoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UtxoOutput__storage_, utxoListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalSelected",
        .dataTypeSpecific.className = NULL,
        .number = UtxoOutput_FieldNumber_TotalSelected,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UtxoOutput__storage_, totalSelected),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UtxoOutput class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UtxoOutput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\000utxoList\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NativeCodeDesc

@implementation NativeCodeDesc

@dynamic name;
@dynamic version;
@dynamic digest;
@dynamic prevVersion;
@dynamic xuperApiVersion;

typedef struct NativeCodeDesc__storage_ {
  uint32_t _has_storage_[1];
  int32_t xuperApiVersion;
  NSString *name;
  NSString *version;
  NSData *digest;
  NSString *prevVersion;
} NativeCodeDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeDesc_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NativeCodeDesc__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeDesc_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NativeCodeDesc__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "digest",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeDesc_FieldNumber_Digest,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NativeCodeDesc__storage_, digest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prevVersion",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeDesc_FieldNumber_PrevVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NativeCodeDesc__storage_, prevVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xuperApiVersion",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeDesc_FieldNumber_XuperApiVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NativeCodeDesc__storage_, xuperApiVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NativeCodeDesc class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NativeCodeDesc__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\013\000\005\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WasmCodeDesc

@implementation WasmCodeDesc

@dynamic runtime;
@dynamic compiler;
@dynamic digest;
@dynamic vmCompiler;

typedef struct WasmCodeDesc__storage_ {
  uint32_t _has_storage_[1];
  NSString *runtime;
  NSString *compiler;
  NSData *digest;
  NSString *vmCompiler;
} WasmCodeDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "runtime",
        .dataTypeSpecific.className = NULL,
        .number = WasmCodeDesc_FieldNumber_Runtime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WasmCodeDesc__storage_, runtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "compiler",
        .dataTypeSpecific.className = NULL,
        .number = WasmCodeDesc_FieldNumber_Compiler,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WasmCodeDesc__storage_, compiler),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "digest",
        .dataTypeSpecific.className = NULL,
        .number = WasmCodeDesc_FieldNumber_Digest,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WasmCodeDesc__storage_, digest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "vmCompiler",
        .dataTypeSpecific.className = NULL,
        .number = WasmCodeDesc_FieldNumber_VmCompiler,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WasmCodeDesc__storage_, vmCompiler),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WasmCodeDesc class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WasmCodeDesc__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeployNativeCodeRequest

@implementation DeployNativeCodeRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic hasDesc, desc;
@dynamic code;
@dynamic address;
@dynamic pubkey;
@dynamic sign;

typedef struct DeployNativeCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NativeCodeDesc *desc;
  NSData *code;
  NSString *address;
  NSData *pubkey;
  NSData *sign;
} DeployNativeCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DeployNativeCodeRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeployNativeCodeRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DeployNativeCodeRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeployNativeCodeRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = GPBStringifySymbol(NativeCodeDesc),
        .number = DeployNativeCodeRequest_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeployNativeCodeRequest__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = DeployNativeCodeRequest_FieldNumber_Code,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeployNativeCodeRequest__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = DeployNativeCodeRequest_FieldNumber_Address,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeployNativeCodeRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = DeployNativeCodeRequest_FieldNumber_Pubkey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeployNativeCodeRequest__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = DeployNativeCodeRequest_FieldNumber_Sign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DeployNativeCodeRequest__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeployNativeCodeRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeployNativeCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeployNativeCodeResponse

@implementation DeployNativeCodeResponse

@dynamic hasHeader, header;

typedef struct DeployNativeCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
} DeployNativeCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DeployNativeCodeResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeployNativeCodeResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeployNativeCodeResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeployNativeCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NativeCodeStatus

@implementation NativeCodeStatus

@dynamic hasDesc, desc;
@dynamic status;
@dynamic healthy;

typedef struct NativeCodeStatus__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NativeCodeDesc *desc;
} NativeCodeStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "desc",
        .dataTypeSpecific.className = GPBStringifySymbol(NativeCodeDesc),
        .number = NativeCodeStatus_FieldNumber_Desc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NativeCodeStatus__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeStatus_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NativeCodeStatus__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "healthy",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeStatus_FieldNumber_Healthy,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NativeCodeStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NativeCodeStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NativeCodeStatusRequest

@implementation NativeCodeStatusRequest

@dynamic hasHeader, header;
@dynamic bcname;

typedef struct NativeCodeStatusRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
} NativeCodeStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = NativeCodeStatusRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NativeCodeStatusRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = NativeCodeStatusRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NativeCodeStatusRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NativeCodeStatusRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NativeCodeStatusRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NativeCodeStatusResponse

@implementation NativeCodeStatusResponse

@dynamic hasHeader, header;
@dynamic statusArray, statusArray_Count;

typedef struct NativeCodeStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *statusArray;
} NativeCodeStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = NativeCodeStatusResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NativeCodeStatusResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "statusArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NativeCodeStatus),
        .number = NativeCodeStatusResponse_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NativeCodeStatusResponse__storage_, statusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NativeCodeStatusResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NativeCodeStatusResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposCandidatesRequest

@implementation DposCandidatesRequest

@dynamic hasHeader, header;
@dynamic bcname;

typedef struct DposCandidatesRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
} DposCandidatesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposCandidatesRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposCandidatesRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DposCandidatesRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposCandidatesRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposCandidatesRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposCandidatesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposCandidatesResponse

@implementation DposCandidatesResponse

@dynamic hasHeader, header;
@dynamic candidatesInfoArray, candidatesInfoArray_Count;

typedef struct DposCandidatesResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *candidatesInfoArray;
} DposCandidatesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposCandidatesResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposCandidatesResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "candidatesInfoArray",
        .dataTypeSpecific.className = NULL,
        .number = DposCandidatesResponse_FieldNumber_CandidatesInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DposCandidatesResponse__storage_, candidatesInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposCandidatesResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposCandidatesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000candidatesInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposNominateRecordsRequest

@implementation DposNominateRecordsRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic address;

typedef struct DposNominateRecordsRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *address;
} DposNominateRecordsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposNominateRecordsRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposNominateRecordsRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DposNominateRecordsRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposNominateRecordsRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = DposNominateRecordsRequest_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DposNominateRecordsRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposNominateRecordsRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposNominateRecordsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposNominateInfo

@implementation DposNominateInfo

@dynamic candidate;
@dynamic txid;

typedef struct DposNominateInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *candidate;
  NSString *txid;
} DposNominateInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "candidate",
        .dataTypeSpecific.className = NULL,
        .number = DposNominateInfo_FieldNumber_Candidate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposNominateInfo__storage_, candidate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = DposNominateInfo_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposNominateInfo__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposNominateInfo class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposNominateInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposNominateRecordsResponse

@implementation DposNominateRecordsResponse

@dynamic hasHeader, header;
@dynamic nominateRecordsArray, nominateRecordsArray_Count;

typedef struct DposNominateRecordsResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *nominateRecordsArray;
} DposNominateRecordsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposNominateRecordsResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposNominateRecordsResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nominateRecordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DposNominateInfo),
        .number = DposNominateRecordsResponse_FieldNumber_NominateRecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DposNominateRecordsResponse__storage_, nominateRecordsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposNominateRecordsResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposNominateRecordsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000nominateRecords\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposNomineeRecordsRequest

@implementation DposNomineeRecordsRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic address;

typedef struct DposNomineeRecordsRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *address;
} DposNomineeRecordsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposNomineeRecordsRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposNomineeRecordsRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DposNomineeRecordsRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposNomineeRecordsRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = DposNomineeRecordsRequest_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DposNomineeRecordsRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposNomineeRecordsRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposNomineeRecordsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposNomineeRecordsResponse

@implementation DposNomineeRecordsResponse

@dynamic hasHeader, header;
@dynamic txid;

typedef struct DposNomineeRecordsResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *txid;
} DposNomineeRecordsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposNomineeRecordsResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposNomineeRecordsResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = DposNomineeRecordsResponse_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposNomineeRecordsResponse__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposNomineeRecordsResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposNomineeRecordsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposVoteRecordsRequest

@implementation DposVoteRecordsRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic address;

typedef struct DposVoteRecordsRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *address;
} DposVoteRecordsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposVoteRecordsRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposVoteRecordsRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DposVoteRecordsRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposVoteRecordsRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = DposVoteRecordsRequest_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DposVoteRecordsRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposVoteRecordsRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposVoteRecordsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - voteRecord

@implementation voteRecord

@dynamic candidate;
@dynamic txid;

typedef struct voteRecord__storage_ {
  uint32_t _has_storage_[1];
  NSString *candidate;
  NSString *txid;
} voteRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "candidate",
        .dataTypeSpecific.className = NULL,
        .number = voteRecord_FieldNumber_Candidate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(voteRecord__storage_, candidate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = voteRecord_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(voteRecord__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[voteRecord class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(voteRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposVoteRecordsResponse

@implementation DposVoteRecordsResponse

@dynamic hasHeader, header;
@dynamic voteTxidRecordsArray, voteTxidRecordsArray_Count;

typedef struct DposVoteRecordsResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *voteTxidRecordsArray;
} DposVoteRecordsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposVoteRecordsResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposVoteRecordsResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voteTxidRecordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(voteRecord),
        .number = DposVoteRecordsResponse_FieldNumber_VoteTxidRecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DposVoteRecordsResponse__storage_, voteTxidRecordsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposVoteRecordsResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposVoteRecordsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000voteTxidRecords\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposVotedRecordsRequest

@implementation DposVotedRecordsRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic address;

typedef struct DposVotedRecordsRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *address;
} DposVotedRecordsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposVotedRecordsRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposVotedRecordsRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DposVotedRecordsRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposVotedRecordsRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = DposVotedRecordsRequest_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DposVotedRecordsRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposVotedRecordsRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposVotedRecordsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - votedRecord

@implementation votedRecord

@dynamic voter;
@dynamic txid;

typedef struct votedRecord__storage_ {
  uint32_t _has_storage_[1];
  NSString *voter;
  NSString *txid;
} votedRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voter",
        .dataTypeSpecific.className = NULL,
        .number = votedRecord_FieldNumber_Voter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(votedRecord__storage_, voter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = votedRecord_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(votedRecord__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[votedRecord class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(votedRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposVotedRecordsResponse

@implementation DposVotedRecordsResponse

@dynamic hasHeader, header;
@dynamic votedTxidRecordsArray, votedTxidRecordsArray_Count;

typedef struct DposVotedRecordsResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *votedTxidRecordsArray;
} DposVotedRecordsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposVotedRecordsResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposVotedRecordsResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "votedTxidRecordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(votedRecord),
        .number = DposVotedRecordsResponse_FieldNumber_VotedTxidRecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DposVotedRecordsResponse__storage_, votedTxidRecordsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposVotedRecordsResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposVotedRecordsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000votedTxidRecords\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposCheckResultsRequest

@implementation DposCheckResultsRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic term;

typedef struct DposCheckResultsRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  int64_t term;
} DposCheckResultsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposCheckResultsRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposCheckResultsRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DposCheckResultsRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposCheckResultsRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "term",
        .dataTypeSpecific.className = NULL,
        .number = DposCheckResultsRequest_FieldNumber_Term,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DposCheckResultsRequest__storage_, term),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposCheckResultsRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposCheckResultsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposCheckResultsResponse

@implementation DposCheckResultsResponse

@dynamic hasHeader, header;
@dynamic term;
@dynamic checkResultArray, checkResultArray_Count;

typedef struct DposCheckResultsResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *checkResultArray;
  int64_t term;
} DposCheckResultsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposCheckResultsResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposCheckResultsResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "term",
        .dataTypeSpecific.className = NULL,
        .number = DposCheckResultsResponse_FieldNumber_Term,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposCheckResultsResponse__storage_, term),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "checkResultArray",
        .dataTypeSpecific.className = NULL,
        .number = DposCheckResultsResponse_FieldNumber_CheckResultArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DposCheckResultsResponse__storage_, checkResultArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposCheckResultsResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposCheckResultsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\000checkResult\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposStatusRequest

@implementation DposStatusRequest

@dynamic hasHeader, header;
@dynamic bcname;

typedef struct DposStatusRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
} DposStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposStatusRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposStatusRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = DposStatusRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposStatusRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposStatusRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposStatusRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposStatusResponse

@implementation DposStatusResponse

@dynamic hasHeader, header;
@dynamic hasStatus, status;

typedef struct DposStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  DposStatus *status;
} DposStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = DposStatusResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposStatusResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(DposStatus),
        .number = DposStatusResponse_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposStatusResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposStatusResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposStatusResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DposStatus

@implementation DposStatus

@dynamic term;
@dynamic blockNum;
@dynamic proposer;
@dynamic proposerNum;
@dynamic checkResultArray, checkResultArray_Count;

typedef struct DposStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *proposer;
  NSMutableArray *checkResultArray;
  int64_t term;
  int64_t blockNum;
  int64_t proposerNum;
} DposStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "term",
        .dataTypeSpecific.className = NULL,
        .number = DposStatus_FieldNumber_Term,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DposStatus__storage_, term),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockNum",
        .dataTypeSpecific.className = NULL,
        .number = DposStatus_FieldNumber_BlockNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DposStatus__storage_, blockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "proposer",
        .dataTypeSpecific.className = NULL,
        .number = DposStatus_FieldNumber_Proposer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DposStatus__storage_, proposer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "proposerNum",
        .dataTypeSpecific.className = NULL,
        .number = DposStatus_FieldNumber_ProposerNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DposStatus__storage_, proposerNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "checkResultArray",
        .dataTypeSpecific.className = NULL,
        .number = DposStatus_FieldNumber_CheckResultArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DposStatus__storage_, checkResultArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DposStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DposStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\000checkResult\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeRPCRequest

@implementation InvokeRPCRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic requestsArray, requestsArray_Count;
@dynamic initiator;
@dynamic authRequireArray, authRequireArray_Count;

typedef struct InvokeRPCRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSMutableArray *requestsArray;
  NSString *initiator;
  NSMutableArray *authRequireArray;
} InvokeRPCRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = InvokeRPCRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeRPCRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRPCRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeRPCRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeRequest),
        .number = InvokeRPCRequest_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeRPCRequest__storage_, requestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initiator",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRPCRequest_FieldNumber_Initiator,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InvokeRPCRequest__storage_, initiator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authRequireArray",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRPCRequest_FieldNumber_AuthRequireArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeRPCRequest__storage_, authRequireArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeRPCRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeRPCRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeRPCResponse

@implementation InvokeRPCResponse

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic hasResponse, response;

typedef struct InvokeRPCResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  InvokeResponse *response;
} InvokeRPCResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = InvokeRPCResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeRPCResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRPCResponse_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeRPCResponse__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "response",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeResponse),
        .number = InvokeRPCResponse_FieldNumber_Response,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InvokeRPCResponse__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeRPCResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeRPCResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeRequest

@implementation InvokeRequest

@dynamic moduleName;
@dynamic contractName;
@dynamic methodName;
@dynamic args, args_Count;
@dynamic resourceLimitsArray, resourceLimitsArray_Count;
@dynamic amount;

typedef struct InvokeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *moduleName;
  NSString *contractName;
  NSString *methodName;
  NSMutableDictionary *args;
  NSMutableArray *resourceLimitsArray;
  NSString *amount;
} InvokeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "moduleName",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRequest_FieldNumber_ModuleName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeRequest__storage_, moduleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contractName",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRequest_FieldNumber_ContractName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeRequest__storage_, contractName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "methodName",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRequest_FieldNumber_MethodName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InvokeRequest__storage_, methodName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "args",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRequest_FieldNumber_Args,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeRequest__storage_, args),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "resourceLimitsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ResourceLimit),
        .number = InvokeRequest_FieldNumber_ResourceLimitsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeRequest__storage_, resourceLimitsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = InvokeRequest_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InvokeRequest__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeResponse

@implementation InvokeResponse

@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic responseArray, responseArray_Count;
@dynamic gasUsed;
@dynamic requestsArray, requestsArray_Count;
@dynamic responsesArray, responsesArray_Count;
@dynamic utxoInputsArray, utxoInputsArray_Count;
@dynamic utxoOutputsArray, utxoOutputsArray_Count;

typedef struct InvokeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  NSMutableArray *responseArray;
  NSMutableArray *requestsArray;
  NSMutableArray *responsesArray;
  NSMutableArray *utxoInputsArray;
  NSMutableArray *utxoOutputsArray;
  int64_t gasUsed;
} InvokeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxInputExt),
        .number = InvokeResponse_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxOutputExt),
        .number = InvokeResponse_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "responseArray",
        .dataTypeSpecific.className = NULL,
        .number = InvokeResponse_FieldNumber_ResponseArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, responseArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "gasUsed",
        .dataTypeSpecific.className = NULL,
        .number = InvokeResponse_FieldNumber_GasUsed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, gasUsed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "requestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeRequest),
        .number = InvokeResponse_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, requestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "responsesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ContractResponse),
        .number = InvokeResponse_FieldNumber_ResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, responsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "utxoInputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxInput),
        .number = InvokeResponse_FieldNumber_UtxoInputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, utxoInputsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "utxoOutputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TxOutput),
        .number = InvokeResponse_FieldNumber_UtxoOutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeResponse__storage_, utxoOutputsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\007\000utxoInputs\000\010\000utxoOutputs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxInputExt

@implementation TxInputExt

@dynamic bucket;
@dynamic key;
@dynamic refTxid;
@dynamic refOffset;

typedef struct TxInputExt__storage_ {
  uint32_t _has_storage_[1];
  int32_t refOffset;
  NSString *bucket;
  NSData *key;
  NSData *refTxid;
} TxInputExt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bucket",
        .dataTypeSpecific.className = NULL,
        .number = TxInputExt_FieldNumber_Bucket,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxInputExt__storage_, bucket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = TxInputExt_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxInputExt__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refTxid",
        .dataTypeSpecific.className = NULL,
        .number = TxInputExt_FieldNumber_RefTxid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxInputExt__storage_, refTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refOffset",
        .dataTypeSpecific.className = NULL,
        .number = TxInputExt_FieldNumber_RefOffset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TxInputExt__storage_, refOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxInputExt class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxInputExt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxOutputExt

@implementation TxOutputExt

@dynamic bucket;
@dynamic key;
@dynamic value;

typedef struct TxOutputExt__storage_ {
  uint32_t _has_storage_[1];
  NSString *bucket;
  NSData *key;
  NSData *value;
} TxOutputExt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bucket",
        .dataTypeSpecific.className = NULL,
        .number = TxOutputExt_FieldNumber_Bucket,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxOutputExt__storage_, bucket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = TxOutputExt_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxOutputExt__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = TxOutputExt_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxOutputExt__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxOutputExt class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxOutputExt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignatureInfo

@implementation SignatureInfo

@dynamic publicKey;
@dynamic sign;

typedef struct SignatureInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *publicKey;
  NSData *sign;
} SignatureInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = SignatureInfo_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignatureInfo__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = SignatureInfo_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignatureInfo__storage_, sign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignatureInfo class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignatureInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001I\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PermissionModel

@implementation PermissionModel

@dynamic rule;
@dynamic acceptValue;

typedef struct PermissionModel__storage_ {
  uint32_t _has_storage_[1];
  PermissionRule rule;
  double acceptValue;
} PermissionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rule",
        .dataTypeSpecific.enumDescFunc = PermissionRule_EnumDescriptor,
        .number = PermissionModel_FieldNumber_Rule,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PermissionModel__storage_, rule),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "acceptValue",
        .dataTypeSpecific.className = NULL,
        .number = PermissionModel_FieldNumber_AcceptValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PermissionModel__storage_, acceptValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PermissionModel class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PermissionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PermissionModel_Rule_RawValue(PermissionModel *message) {
  GPBDescriptor *descriptor = [PermissionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PermissionModel_FieldNumber_Rule];
  return GPBGetMessageInt32Field(message, field);
}

void SetPermissionModel_Rule_RawValue(PermissionModel *message, int32_t value) {
  GPBDescriptor *descriptor = [PermissionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PermissionModel_FieldNumber_Rule];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AkSet

@implementation AkSet

@dynamic aksArray, aksArray_Count;

typedef struct AkSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *aksArray;
} AkSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aksArray",
        .dataTypeSpecific.className = NULL,
        .number = AkSet_FieldNumber_AksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AkSet__storage_, aksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AkSet class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AkSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AkSets

@implementation AkSets

@dynamic sets, sets_Count;
@dynamic expression;

typedef struct AkSets__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *sets;
  NSString *expression;
} AkSets__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sets",
        .dataTypeSpecific.className = GPBStringifySymbol(AkSet),
        .number = AkSets_FieldNumber_Sets,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AkSets__storage_, sets),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expression",
        .dataTypeSpecific.className = NULL,
        .number = AkSets_FieldNumber_Expression,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AkSets__storage_, expression),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AkSets class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AkSets__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Acl

@implementation Acl

@dynamic hasPm, pm;
@dynamic aksWeight, aksWeight_Count;
@dynamic hasAkSets, akSets;

typedef struct Acl__storage_ {
  uint32_t _has_storage_[1];
  PermissionModel *pm;
  GPBStringDoubleDictionary *aksWeight;
  AkSets *akSets;
} Acl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pm",
        .dataTypeSpecific.className = GPBStringifySymbol(PermissionModel),
        .number = Acl_FieldNumber_Pm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Acl__storage_, pm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aksWeight",
        .dataTypeSpecific.className = NULL,
        .number = Acl_FieldNumber_AksWeight,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Acl__storage_, aksWeight),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "akSets",
        .dataTypeSpecific.className = GPBStringifySymbol(AkSets),
        .number = Acl_FieldNumber_AkSets,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Acl__storage_, akSets),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Acl class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Acl__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\t\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AclStatus

@implementation AclStatus

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic accountName;
@dynamic contractName;
@dynamic methodName;
@dynamic confirmed;
@dynamic hasAcl, acl;

typedef struct AclStatus__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *accountName;
  NSString *contractName;
  NSString *methodName;
  Acl *acl;
} AclStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = AclStatus_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AclStatus__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = AclStatus_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AclStatus__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountName",
        .dataTypeSpecific.className = NULL,
        .number = AclStatus_FieldNumber_AccountName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AclStatus__storage_, accountName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contractName",
        .dataTypeSpecific.className = NULL,
        .number = AclStatus_FieldNumber_ContractName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AclStatus__storage_, contractName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "methodName",
        .dataTypeSpecific.className = NULL,
        .number = AclStatus_FieldNumber_MethodName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AclStatus__storage_, methodName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "confirmed",
        .dataTypeSpecific.className = NULL,
        .number = AclStatus_FieldNumber_Confirmed,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "acl",
        .dataTypeSpecific.className = GPBStringifySymbol(Acl),
        .number = AclStatus_FieldNumber_Acl,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AclStatus__storage_, acl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AclStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AclStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\013\000\004\014\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IdentityAuth

@implementation IdentityAuth

@dynamic sign;
@dynamic pubkey;
@dynamic addr;
@dynamic peerId;
@dynamic timestamp;

typedef struct IdentityAuth__storage_ {
  uint32_t _has_storage_[1];
  NSData *sign;
  NSData *pubkey;
  NSString *addr;
  NSString *peerId;
  NSString *timestamp;
} IdentityAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = IdentityAuth_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IdentityAuth__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = IdentityAuth_FieldNumber_Pubkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IdentityAuth__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = IdentityAuth_FieldNumber_Addr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IdentityAuth__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peerId",
        .dataTypeSpecific.className = NULL,
        .number = IdentityAuth_FieldNumber_PeerId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IdentityAuth__storage_, peerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = IdentityAuth_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IdentityAuth__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IdentityAuth class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IdentityAuth__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\005A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IdentityAuths

@implementation IdentityAuths

@dynamic authArray, authArray_Count;

typedef struct IdentityAuths__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *authArray;
} IdentityAuths__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authArray",
        .dataTypeSpecific.className = GPBStringifySymbol(IdentityAuth),
        .number = IdentityAuths_FieldNumber_AuthArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IdentityAuths__storage_, authArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IdentityAuths class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IdentityAuths__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResourceLimit

@implementation ResourceLimit

@dynamic type;
@dynamic limit;

typedef struct ResourceLimit__storage_ {
  uint32_t _has_storage_[1];
  ResourceType type;
  int64_t limit;
} ResourceLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ResourceType_EnumDescriptor,
        .number = ResourceLimit_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResourceLimit__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = ResourceLimit_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResourceLimit__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResourceLimit class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceLimit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResourceLimit_Type_RawValue(ResourceLimit *message) {
  GPBDescriptor *descriptor = [ResourceLimit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResourceLimit_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetResourceLimit_Type_RawValue(ResourceLimit *message, int32_t value) {
  GPBDescriptor *descriptor = [ResourceLimit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResourceLimit_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AK2AccountRequest

@implementation AK2AccountRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic address;

typedef struct AK2AccountRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *address;
} AK2AccountRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = AK2AccountRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AK2AccountRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = AK2AccountRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AK2AccountRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AK2AccountRequest_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AK2AccountRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AK2AccountRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AK2AccountRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AK2AccountResponse

@implementation AK2AccountResponse

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic accountArray, accountArray_Count;

typedef struct AK2AccountResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSMutableArray *accountArray;
} AK2AccountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = AK2AccountResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AK2AccountResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = AK2AccountResponse_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AK2AccountResponse__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountArray",
        .dataTypeSpecific.className = NULL,
        .number = AK2AccountResponse_FieldNumber_AccountArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AK2AccountResponse__storage_, accountArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AK2AccountResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AK2AccountResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountContractsRequest

@implementation GetAccountContractsRequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic account;

typedef struct GetAccountContractsRequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *account;
} GetAccountContractsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = GetAccountContractsRequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountContractsRequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = GetAccountContractsRequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccountContractsRequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "account",
        .dataTypeSpecific.className = NULL,
        .number = GetAccountContractsRequest_FieldNumber_Account,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAccountContractsRequest__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountContractsRequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountContractsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountContractsResponse

@implementation GetAccountContractsResponse

@dynamic hasHeader, header;
@dynamic contractsStatusArray, contractsStatusArray_Count;

typedef struct GetAccountContractsResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *contractsStatusArray;
} GetAccountContractsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = GetAccountContractsResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountContractsResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contractsStatusArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ContractStatus),
        .number = GetAccountContractsResponse_FieldNumber_ContractsStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAccountContractsResponse__storage_, contractsStatusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountContractsResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountContractsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractStatus

@implementation ContractStatus

@dynamic contractName;
@dynamic txid;
@dynamic desc;
@dynamic isBanned;

typedef struct ContractStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *contractName;
  NSString *txid;
  NSData *desc;
} ContractStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractName",
        .dataTypeSpecific.className = NULL,
        .number = ContractStatus_FieldNumber_ContractName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractStatus__storage_, contractName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = ContractStatus_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractStatus__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = ContractStatus_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractStatus__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "isBanned",
        .dataTypeSpecific.className = NULL,
        .number = ContractStatus_FieldNumber_IsBanned,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractStatus class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PreExecWithSelectUTXORequest

@implementation PreExecWithSelectUTXORequest

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic address;
@dynamic totalAmount;
@dynamic hasSignInfo, signInfo;
@dynamic needLock;
@dynamic hasRequest, request;

typedef struct PreExecWithSelectUTXORequest__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  NSString *address;
  InvokeRPCRequest *request;
  SignatureInfo *signInfo;
  int64_t totalAmount;
} PreExecWithSelectUTXORequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = PreExecWithSelectUTXORequest_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXORequest__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = PreExecWithSelectUTXORequest_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXORequest__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = PreExecWithSelectUTXORequest_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXORequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalAmount",
        .dataTypeSpecific.className = NULL,
        .number = PreExecWithSelectUTXORequest_FieldNumber_TotalAmount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXORequest__storage_, totalAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeRPCRequest),
        .number = PreExecWithSelectUTXORequest_FieldNumber_Request,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXORequest__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SignatureInfo),
        .number = PreExecWithSelectUTXORequest_FieldNumber_SignInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXORequest__storage_, signInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "needLock",
        .dataTypeSpecific.className = NULL,
        .number = PreExecWithSelectUTXORequest_FieldNumber_NeedLock,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PreExecWithSelectUTXORequest class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PreExecWithSelectUTXORequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\013\000\006\010\000\007\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PreExecWithSelectUTXOResponse

@implementation PreExecWithSelectUTXOResponse

@dynamic hasHeader, header;
@dynamic bcname;
@dynamic hasResponse, response;
@dynamic hasUtxoOutput, utxoOutput;

typedef struct PreExecWithSelectUTXOResponse__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSString *bcname;
  InvokeResponse *response;
  UtxoOutput *utxoOutput;
} PreExecWithSelectUTXOResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(Header),
        .number = PreExecWithSelectUTXOResponse_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXOResponse__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bcname",
        .dataTypeSpecific.className = NULL,
        .number = PreExecWithSelectUTXOResponse_FieldNumber_Bcname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXOResponse__storage_, bcname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "response",
        .dataTypeSpecific.className = GPBStringifySymbol(InvokeResponse),
        .number = PreExecWithSelectUTXOResponse_FieldNumber_Response,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXOResponse__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "utxoOutput",
        .dataTypeSpecific.className = GPBStringifySymbol(UtxoOutput),
        .number = PreExecWithSelectUTXOResponse_FieldNumber_UtxoOutput,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PreExecWithSelectUTXOResponse__storage_, utxoOutput),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PreExecWithSelectUTXOResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PreExecWithSelectUTXOResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractResponse

@implementation ContractResponse

@dynamic status;
@dynamic message;
@dynamic body;

typedef struct ContractResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *message;
  NSData *body;
} ContractResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ContractResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = ContractResponse_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = ContractResponse_FieldNumber_Body,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractResponse__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractResponse class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModifyBlock

@implementation ModifyBlock

@dynamic effectiveTxid;
@dynamic marked;
@dynamic effectiveHeight;
@dynamic publicKey;
@dynamic sign;

typedef struct ModifyBlock__storage_ {
  uint32_t _has_storage_[1];
  NSString *effectiveTxid;
  NSString *publicKey;
  NSString *sign;
  int64_t effectiveHeight;
} ModifyBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effectiveTxid",
        .dataTypeSpecific.className = NULL,
        .number = ModifyBlock_FieldNumber_EffectiveTxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModifyBlock__storage_, effectiveTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "marked",
        .dataTypeSpecific.className = NULL,
        .number = ModifyBlock_FieldNumber_Marked,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "effectiveHeight",
        .dataTypeSpecific.className = NULL,
        .number = ModifyBlock_FieldNumber_EffectiveHeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModifyBlock__storage_, effectiveHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = ModifyBlock_FieldNumber_PublicKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModifyBlock__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = ModifyBlock_FieldNumber_Sign,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModifyBlock__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModifyBlock class]
                                     rootClass:[XchainRoot class]
                                          file:XchainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModifyBlock__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
